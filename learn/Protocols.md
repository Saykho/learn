# Протоколы API: SOAP, gRPC, Webhooks

## 1. SOAP (Simple Object Access Protocol)

### Что это
SOAP — XML‑базирующийся протокол обмена сообщениями для вызова удалённых методов. Часто использует HTTP(S) как транспорт, но допускает и другие транспорты.

### Как работает
- Клиент формирует SOAP‑envelope (XML) с вызовом метода и параметрами.
- Отправляет на endpoint (обычно POST /soap).
- Сервер возвращает SOAP‑ответ (XML) с результатом или ошибкой.
- Описания сервиса — WSDL (Web Services Description Language).

### Пример
```xml
POST /service HTTP/1.1
Host: example.com
Content-Type: text/xml; charset=utf-8
Content-Length: ...

<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <m:GetUser xmlns:m="http://example.com/user">
      <m:Id>123</m:Id>
    </m:GetUser>
  </soap:Body>
</soap:Envelope>
```

### Плюсы

Строгая стандартизация (WSDL, SOAP faults).

Хорошо подходит для корпоративных интеграций (legacy, банковские системы).

Поддержка сложных контрактов, WS‑Security, транзакций и т.д.

### Минусы

Тяжеловесен (XML, вербозность).

Сложнее в разработке и дебаге по сравнению с REST/JSON.

Меньше "web‑friendly" — не так удобен для браузерного фронтенда.

### Безопасность / особенности

Часто используется WS‑Security (подпись, шифрование).

Лучше работать через HTTPS.

WSDL генерирует strongly-typed клиенты.

## 2. gRPC
### Что это

gRPC — высокопроизводительный RPC‑фреймворк от Google. Описания API делаются в protobuf (Protocol Buffers). Транспорт — HTTP/2 (обычно TLS).

### Как работает

Описание сервисов и сообщений в .proto файле.

Генерация клиента и сервера под выбранные языки.

Поддержка unary, server streaming, client streaming и bidi streaming.

Передача бинарных protobuf‑сообщений по HTTP/2.

### Пример .proto
```
syntax = "proto3";

service UserService {
  rpc GetUser (GetUserRequest) returns (GetUserResponse);
  rpc StreamUpdates (StreamRequest) returns (stream Update);
}

message GetUserRequest { int32 id = 1; }
message GetUserResponse { int32 id = 1; string name = 2; }
message StreamRequest { string topic = 1; }
message Update { string msg = 1; }
```
### Плюсы

Высокая производительность и маленький размер сообщений (бинарный формат).

Автогенерация клиентов/серверов для многих языков.

Поддержка стриминга и двунаправленного обмена.

Дефолтно использует HTTP/2 — мультиплексирование, низкая задержка.

### Минусы

Бинарный формат сложно дебажить "вручную" (но есть инструменты).

Не очень "браузер‑дружелюбен" (нужен gRPC‑Web для фронтенда).

Требует компиляции .proto и привычки к protobuf.

### Безопасность / особенности

Обычно используется TLS (mTLS в корпоративных сетях).

Поддержка аутентификации и метаданных (headers/metadata).

Хорош для микросервисов, real‑time систем, стриминговых задач.

## 3. Webhooks
### Что это

Webhooks — способ "push" уведомления: одна система делает HTTP(S) POST на заранее зарегистрированный URL другой системы при каком‑то событии.

### Как работает

При событии (например, новый заказ) сервис A делает POST JSON/XML на URL, который заранее настроил сервис B.

Сервис B принимает и обрабатывает уведомление (асинхронно).

### Пример (payload)
```
POST /webhooks/order HTTP/1.1
Host: receiver.example
Content-Type: application/json

{
  "orderId": 123,
  "status": "created",
  "amount": 99.9
}
```
### Плюсы

Простая и эффективная модель для событий: не нужно опрашивать API (no polling).

Легко интегрировать и масштабировать.

Подходит для уведомлений, CI/CD триггеров, платежных систем и т.д.

### Минусы

Надо обрабатывать повторные доставки (retries), дедупликацию.

Безопасность: нужно верифицировать, что запрос пришёл от ожидаемого отправителя.

Требуется публичный endpoint (или туннели вроде ngrok при локальной разработке).

### Безопасность / лучшие практики

Подпись payload (HMAC) + проверка на стороне получателя.

- Отправитель кладёт заголовок с подписью: X-Signature: sha256=...

- Получатель пересчитывает HMAC и сравнивает.

Использовать HTTPS.

Ограничивать по IP/файрволу если возможно.

Обрабатывать idempotency (идентификаторы событий) и ретраи.

Время ответа должно быть быстрое; если обработка долгая — отвечать 200 и обрабатывать асинхронно.

## 4. Сравнение

| Характеристика       | SOAP                   | gRPC                   | Webhooks                        |
|---------------------|-----------------------|-----------------------|---------------------------------|
| Формат              | XML (WSDL)            | Protobuf (binary)     | JSON/XML (HTTP POST)            |
| Транспорт           | HTTP, SMTP и др.      | HTTP/2                | HTTP/HTTPS                      |
| Поддержка стриминга | Частично (WS)         | Да (native)           | Нет (однонаправленные PUSH)     |
| Подходит для        | Корпоративных систем, транзакций | Микросервисов, real‑time | Событийных уведомлений          |
| Клиент для браузера | Плохая интеграция     | Требуется gRPC‑Web    | Отлично (webhook — серверная сторона) |
| Простота разработки | Сложнее               | Требуется proto, но удобнее после генерации | Очень просто (HTTP POST) |

### Когда выбирать

SOAP — когда вы интегрируетесь с legacy корпоративными сервисами, требуется WS‑Security, сложные контрактные требования.

gRPC — если нужны высокая производительность, стримы, типизация и автогенерация клиентов между микросервисами.

Webhooks — для событийных интеграций и push‑уведомлений: быстрый, лёгкий и эффективный.

## 5. Интеграция с фронтендом

SOAP: фронтенд обычно не работает с SOAP напрямую. В веб‑проектах делают сервер‑прокси, который общается с SOAP и выдаёт JSON для клиента.

gRPC: браузеры не поддерживают native gRPC; используется gRPC‑Web (прокси/посредник) или конвертация в REST/JSON на стороне BFF (backend‑for‑frontend).

Webhooks: фронтенду обычно не приходят вебхуки напрямую — это серверная ответственность. Для разработки можно использовать веб‑push, WebSocket или поллинг в браузере, либо проксировать webhook-события в UI через сервер/WS.
